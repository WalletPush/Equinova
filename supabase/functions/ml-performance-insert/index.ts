// supabase/functions/ml-performance-insert/index.ts
Deno.serve(async (req) => {
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, GET, OPTIONS, PUT, DELETE, PATCH",
    "Access-Control-Max-Age": "86400",
    "Access-Control-Allow-Credentials": "false",
  };
  if (req.method === "OPTIONS") {
    return new Response(null, { status: 200, headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const TARGET_DATE = "2025-09-04"; // change if needed

    console.log("=== ML PERFORMANCE: INSERT ONLY ===");
    console.log("Target date:", TARGET_DATE);

    // 1) Races for date
    const racesRes = await fetch(
      `${supabaseUrl}/rest/v1/races?date=eq.${TARGET_DATE}&select=race_id`,
      { headers: { Authorization: `Bearer ${supabaseKey}`, apikey: supabaseKey } },
    );
    if (!racesRes.ok) throw new Error(`races fetch failed: ${racesRes.status} ${await racesRes.text()}`);
    const races: Array<{ race_id: string }> = await racesRes.json();
    if (races.length === 0) {
      return new Response(JSON.stringify({ success: true, message: "No races found", inserted: 0 }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }
    const raceIds = races.map(r => r.race_id);
    console.log(`Races: ${raceIds.length}`);

    // Helper to build in.(...) filter
    const inList = raceIds.join(",");

    // 2) Entries (model probabilities)
    const entriesRes = await fetch(
      `${supabaseUrl}/rest/v1/race_entries?race_id=in.(${inList})&select=race_id,horse_id,horse_name,mlp_proba,rf_proba,xgboost_proba,benter_proba,ensemble_proba`,
      { headers: { Authorization: `Bearer ${supabaseKey}`, apikey: supabaseKey } },
    );
    if (!entriesRes.ok) throw new Error(`entries fetch failed: ${entriesRes.status} ${await entriesRes.text()}`);
    const entries = await entriesRes.json();

    // 3) Runners (actual finishing positions)
    const runnersRes = await fetch(
      `${supabaseUrl}/rest/v1/race_runners?race_id=in.(${inList})&select=race_id,horse_id,position`,
      { headers: { Authorization: `Bearer ${supabaseKey}`, apikey: supabaseKey } },
    );
    if (!runnersRes.ok) throw new Error(`runners fetch failed: ${runnersRes.status} ${await runnersRes.text()}`);
    const runners = await runnersRes.json();

    // Index runners by (race_id, horse_id) â†’ numeric position
    const posMap = new Map<string, number>();
    for (const r of runners) {
      const p = Number(r?.position);
      if (Number.isFinite(p) && p >= 1) {
        posMap.set(`${r.race_id}::${r.horse_id}`, p);
      }
    }

    const models = [
      { name: "mlp", field: "mlp_proba" },
      { name: "rf", field: "rf_proba" },
      { name: "xgboost", field: "xgboost_proba" },
      { name: "benter", field: "benter_proba" },
      { name: "ensemble", field: "ensemble_proba" },
    ] as const;

    // Build rows to INSERT (array payload)
    const rows: any[] = [];

    for (const raceId of raceIds) {
      const raceEntries = entries.filter((e: any) => e.race_id === raceId);

      for (const model of models) {
        // pick top horse for this model
        let top: any = null;
        let best = 0;
        for (const e of raceEntries) {
          const prob = Number(e[model.field] ?? 0);
          if (Number.isFinite(prob) && prob > best) {
            best = prob;
            top = e;
          }
        }
        if (!top || best <= 0) continue;

        const key = `${raceId}::${top.horse_id}`;
        const pos = posMap.get(key);
        if (!Number.isFinite(pos)) continue;

        rows.push({
          race_id: raceId,
          horse_id: top.horse_id,
          horse_name: top.horse_name,
          model_name: model.name,
          predicted_probability: Number(best.toFixed(6)),
          actual_position: pos,                 // booleans are GENERATED by DB
          created_at: new Date().toISOString(),
        });
      }
    }

    if (rows.length === 0) {
      return new Response(JSON.stringify({
        success: true,
        message: "Nothing to insert (no top picks with valid positions)",
        inserted: 0,
        races_processed: raceIds.length,
      }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    // 4) BULK INSERT (array payload). No on_conflict. Pure INSERT.
    // NOTE: If you run this twice without deleting, it will 409 if you have a unique index.
    const insertRes = await fetch(`${supabaseUrl}/rest/v1/ml_model_race_results`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${supabaseKey}`,
        apikey: supabaseKey,
        "Content-Type": "application/json",
        "Prefer": "return=representation", // return inserted rows
      },
      body: JSON.stringify(rows),
    });

    if (!insertRes.ok) {
      const errBody = await insertRes.text();
      return new Response(JSON.stringify({
        success: false,
        message: "INSERT failed",
        status: insertRes.status,
        error: errBody.slice(0, 2000),
        rows_attempted: rows.length,
      }), { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    const saved = await insertRes.json();
    const inserted = Array.isArray(saved) ? saved.length : 0;

    return new Response(JSON.stringify({
      success: true,
      message: "ML performance data populated (INSERT only)",
      races_processed: raceIds.length,
      rows_attempted: rows.length,
      rows_inserted: inserted,
      // echo first few for sanity
      sample: saved.slice ? saved.slice(0, 3) : saved,
      timestamp: new Date().toISOString(),
    }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });

  } catch (err: any) {
    console.error("ERROR:", err?.message || err);
    return new Response(JSON.stringify({
      success: false,
      error: err?.message || String(err),
      timestamp: new Date().toISOString(),
    }), { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
});

